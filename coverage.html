
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/piotrklosek/signing-service-challenge-go/cmd/migrate.go (0.0%)</option>
				
				<option value="file1">github.com/piotrklosek/signing-service-challenge-go/cmd/root.go (0.0%)</option>
				
				<option value="file2">github.com/piotrklosek/signing-service-challenge-go/cmd/server.go (0.0%)</option>
				
				<option value="file3">github.com/piotrklosek/signing-service-challenge-go/internal/api/handlers/devices.go (87.9%)</option>
				
				<option value="file4">github.com/piotrklosek/signing-service-challenge-go/internal/api/handlers/health.go (0.0%)</option>
				
				<option value="file5">github.com/piotrklosek/signing-service-challenge-go/internal/api/handlers/signatures.go (0.0%)</option>
				
				<option value="file6">github.com/piotrklosek/signing-service-challenge-go/internal/api/handlers/users.go (0.0%)</option>
				
				<option value="file7">github.com/piotrklosek/signing-service-challenge-go/internal/api/middleware.go (0.0%)</option>
				
				<option value="file8">github.com/piotrklosek/signing-service-challenge-go/internal/api/router.go (0.0%)</option>
				
				<option value="file9">github.com/piotrklosek/signing-service-challenge-go/internal/config/config.go (0.0%)</option>
				
				<option value="file10">github.com/piotrklosek/signing-service-challenge-go/internal/domain/device.go (84.6%)</option>
				
				<option value="file11">github.com/piotrklosek/signing-service-challenge-go/internal/domain/signature.go (100.0%)</option>
				
				<option value="file12">github.com/piotrklosek/signing-service-challenge-go/internal/domain/signer.go (84.6%)</option>
				
				<option value="file13">github.com/piotrklosek/signing-service-challenge-go/internal/persistence/inmemory/device_repo.go (0.0%)</option>
				
				<option value="file14">github.com/piotrklosek/signing-service-challenge-go/internal/persistence/inmemory/inmemory.go (0.0%)</option>
				
				<option value="file15">github.com/piotrklosek/signing-service-challenge-go/internal/persistence/inmemory/signature_repo.go (0.0%)</option>
				
				<option value="file16">github.com/piotrklosek/signing-service-challenge-go/internal/persistence/inmemory/user_repo.go (0.0%)</option>
				
				<option value="file17">github.com/piotrklosek/signing-service-challenge-go/internal/persistence/mongo/device_repo.go (0.0%)</option>
				
				<option value="file18">github.com/piotrklosek/signing-service-challenge-go/internal/persistence/mongo/mongo.go (0.0%)</option>
				
				<option value="file19">github.com/piotrklosek/signing-service-challenge-go/internal/persistence/mongo/signature_repo.go (0.0%)</option>
				
				<option value="file20">github.com/piotrklosek/signing-service-challenge-go/internal/persistence/mongo/user_repo.go (0.0%)</option>
				
				<option value="file21">github.com/piotrklosek/signing-service-challenge-go/internal/persistence/postgres/device_repo.go (0.0%)</option>
				
				<option value="file22">github.com/piotrklosek/signing-service-challenge-go/internal/persistence/postgres/postgres.go (0.0%)</option>
				
				<option value="file23">github.com/piotrklosek/signing-service-challenge-go/internal/persistence/postgres/signature_repo.go (0.0%)</option>
				
				<option value="file24">github.com/piotrklosek/signing-service-challenge-go/internal/persistence/postgres/user_repo.go (0.0%)</option>
				
				<option value="file25">github.com/piotrklosek/signing-service-challenge-go/internal/utils/crypto/ecdsa.go (0.0%)</option>
				
				<option value="file26">github.com/piotrklosek/signing-service-challenge-go/internal/utils/crypto/generation.go (0.0%)</option>
				
				<option value="file27">github.com/piotrklosek/signing-service-challenge-go/internal/utils/crypto/rsa.go (0.0%)</option>
				
				<option value="file28">github.com/piotrklosek/signing-service-challenge-go/internal/utils/crypto/signer.go (0.0%)</option>
				
				<option value="file29">github.com/piotrklosek/signing-service-challenge-go/internal/utils/jsonw/jsonw.go (0.0%)</option>
				
				<option value="file30">github.com/piotrklosek/signing-service-challenge-go/internal/utils/logger/logger.go (0.0%)</option>
				
				<option value="file31">github.com/piotrklosek/signing-service-challenge-go/internal/validation/rules.go (0.0%)</option>
				
				<option value="file32">github.com/piotrklosek/signing-service-challenge-go/internal/validation/validation.go (0.0%)</option>
				
				<option value="file33">github.com/piotrklosek/signing-service-challenge-go/main.go (0.0%)</option>
				
				<option value="file34">github.com/piotrklosek/signing-service-challenge-go/mocks/database/mock_devices_repo.go (0.0%)</option>
				
				<option value="file35">github.com/piotrklosek/signing-service-challenge-go/mocks/database/mock_signature_repo.go (0.0%)</option>
				
				<option value="file36">github.com/piotrklosek/signing-service-challenge-go/mocks/database/mock_user_repo.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "fmt"
        "log"

        "github.com/piotrklosek/signing-service-challenge-go/internal/config"
        "github.com/piotrklosek/signing-service-challenge-go/internal/persistence/postgres"
        "github.com/spf13/cobra"
)

var migrateCmd = &amp;cobra.Command{
        Use:   "migrate",
        Short: "Run database migrations (Postgres only)",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                cfg := config.Load()

                if cfg.DBType != "postgres" </span><span class="cov0" title="0">{
                        log.Fatal("migrate command is only supported for Postgres backend")
                }</span>

                <span class="cov0" title="0">if err := postgres.RunMigrations(cfg.Postgres.DSN); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("migration failed: %v", err)
                }</span>

                <span class="cov0" title="0">fmt.Println("Migrations applied successfully")</span>
        },
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(migrateCmd)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "fmt"
        "os"
        "strings"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var cfgFile string

var rootCmd = &amp;cobra.Command{
        Use:   "signature-service",
        Short: "Signature Service - signing API",
        Long:  "Signature Service - signing API this microservice was created as a part of recruitment process",
}

// Execute command
func Execute() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                os.Exit(1)
        }</span>
}

func init() <span class="cov0" title="0">{
        cobra.OnInitialize(initConfig)

        rootCmd.PersistentFlags().StringVar(&amp;cfgFile, "config", "", "Config file (yaml/json)")
        rootCmd.CompletionOptions.HiddenDefaultCmd = true

        viper.SetEnvPrefix("SIG") // np. SIG_PORT, SIG_DB_TYPE
        viper.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
        viper.AutomaticEnv()
}</span>

func initConfig() <span class="cov0" title="0">{
        if cfgFile != "" </span><span class="cov0" title="0">{
                viper.SetConfigFile(cfgFile)
        }</span> else<span class="cov0" title="0"> {
                viper.SetConfigName("config.json")
                viper.AddConfigPath(".")
        }</span>

        // defaults
        <span class="cov0" title="0">viper.SetDefault("port", "8080")
        viper.SetDefault("db.type", "memory")</span>

}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/piotrklosek/signing-service-challenge-go/internal/persistence"
        "github.com/piotrklosek/signing-service-challenge-go/internal/persistence/inmemory"
        "github.com/piotrklosek/signing-service-challenge-go/internal/persistence/mongo"
        "github.com/piotrklosek/signing-service-challenge-go/internal/persistence/postgres"
        "github.com/piotrklosek/signing-service-challenge-go/internal/utils/logger"
        "go.uber.org/zap"

        "github.com/piotrklosek/signing-service-challenge-go/internal/api"
        "github.com/piotrklosek/signing-service-challenge-go/internal/config"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var serverCmd = &amp;cobra.Command{
        Use:   "server",
        Short: "Run the Signature Service API server",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                cfg := config.Load()

                var (
                        deviceRepo    persistence.DeviceRepository
                        signatureRepo persistence.SignatureRepository
                        userRepo      persistence.UserRepository
                        err           error
                )
                shutdownCtx, cancel := context.WithTimeout(cmd.Context(), 5*time.Second)
                // create logger
                logger := logger.CreateLogger("server")

                switch cfg.DBType </span>{
                case "postgres":<span class="cov0" title="0">
                        deviceRepo, signatureRepo, userRepo, err = postgres.NewRepositories(cfg.Postgres.DSN)</span>
                case "mongo":<span class="cov0" title="0">
                        deviceRepo, signatureRepo, userRepo, err = mongo.NewRepositories(cfg.Mongo.URI, cfg.Mongo.Database)</span>
                default:<span class="cov0" title="0"> // inmemory
                        inMemoryStore, err := inmemory.NewMemoryStore(cfg.InMemory.DBFilePath)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Fatal("enabled to create inmemory store", zap.Error(err))
                                panic(err)</span>
                        }
                        <span class="cov0" title="0">deviceRepo = inMemoryStore.DeviceRepo
                        signatureRepo = inMemoryStore.SignatureRepo
                        userRepo = inMemoryStore.UserRepo
                        defer inMemoryStore.SaveOnShutdown(shutdownCtx)</span>
                }

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("failed to initialize storage", zap.Error(err))
                }</span>

                <span class="cov0" title="0">router := api.NewRouter(deviceRepo, signatureRepo, userRepo)

                srv := &amp;http.Server{
                        Addr:    fmt.Sprintf(":%s", cfg.Port),
                        Handler: router,
                }

                go func() </span><span class="cov0" title="0">{
                        logger.Info("Signature Service running",
                                zap.String("port", cfg.Port), zap.String("dbType", cfg.DBType))
                        if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                                logger.Fatal("server failed", zap.Error(err))
                        }</span>
                }()

                <span class="cov0" title="0">quit := make(chan os.Signal, 1)
                signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
                &lt;-quit
                logger.Info("Shutting down server...")
                // dump db backup

                defer cancel()
                if err := srv.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Server forced to shutdown", zap.Error(err))
                }</span>
                <span class="cov0" title="0">logger.Info("Server stopped gracefully")</span>
        },
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(serverCmd)

        // Flags specific to the server command
        serverCmd.Flags().String("port", "8080", "Port for HTTP server")
        _ = viper.BindPFlag("port", serverCmd.Flags().Lookup("port"))

        serverCmd.Flags().String("db", "memory", "Database type (memory|postgres|mongo)")
        _ = viper.BindPFlag("db.type", serverCmd.Flags().Lookup("db"))

        serverCmd.Flags().String("db.filepath", "./database/inmemory/database.json", "Database file path")
        _ = viper.BindPFlag("db.inmemory.dbfilepath", serverCmd.Flags().Lookup("db.filepath"))
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        "github.com/google/uuid"
        "github.com/piotrklosek/signing-service-challenge-go/internal/domain"
        "github.com/piotrklosek/signing-service-challenge-go/internal/persistence"
        "github.com/piotrklosek/signing-service-challenge-go/internal/utils/jsonw"
        "github.com/piotrklosek/signing-service-challenge-go/internal/validation"
)

type DeviceHandler struct {
        deviceRepo persistence.DeviceRepository
        userRepo   persistence.UserRepository
}

func NewDeviceHandler(deviceRepo persistence.DeviceRepository, userRepo persistence.UserRepository) *DeviceHandler <span class="cov8" title="1">{
        return &amp;DeviceHandler{deviceRepo: deviceRepo, userRepo: userRepo}
}</span>

type CreateDeviceRequest struct {
        UserID    string `json:"user_id" validate:"required,uuid4"`
        Algorithm string `json:"algorithm" validate:"required,algorithm"`
        Label     string `json:"label" validate:"omitempty,min=3,max=100"`
}

func (h *DeviceHandler) CreateDevice(w http.ResponseWriter, r *http.Request) error <span class="cov8" title="1">{
        var req CreateDeviceRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                jsonw.Error(w, "invalid json", nil, http.StatusBadRequest)
                return fmt.Errorf("%v - %v", ErrInvalidJson, err)
        }</span>
        <span class="cov8" title="1">if err := validation.ValidateStruct(&amp;req); err != nil </span><span class="cov0" title="0">{
                jsonw.Error(w, err.Error(), nil, http.StatusBadRequest)
                return err
        }</span>

        // TODO move to middelware layer
        // check if user exists
        <span class="cov8" title="1">if _, err := h.userRepo.GetByID(r.Context(), req.UserID); err != nil </span><span class="cov8" title="1">{
                jsonw.Error(w, "user not found", nil, http.StatusBadRequest)
                return fmt.Errorf("%v - %v", ErrUserNotFounc, err)
        }</span>

        <span class="cov8" title="1">device := &amp;domain.SignatureDevice{
                ID:               uuid.NewString(),
                UserID:           req.UserID,
                Algorithm:        domain.AlgorithmType(req.Algorithm),
                Label:            req.Label,
                SignatureCounter: 0,
                LastSignature:    "", // fill during signing document
                CreatedAt:        time.Now(),
                UpdatedAt:        time.Now(),
        }

        if err := device.GenerateKeys(); err != nil </span><span class="cov0" title="0">{
                jsonw.Error(w, err.Error(), nil, http.StatusInternalServerError)
                return fmt.Errorf("%v - %v", ErrGenerateKeys, err)
        }</span>

        <span class="cov8" title="1">if err := h.deviceRepo.Create(r.Context(), device); err != nil </span><span class="cov8" title="1">{
                jsonw.Error(w, err.Error(), nil, http.StatusInternalServerError)
                return fmt.Errorf("%v - %v", ErrCreatingDevice, err)
        }</span>
        <span class="cov8" title="1">jsonw.Success(w, device, http.StatusCreated)
        return nil</span>
}

func (h *DeviceHandler) ListDevices(w http.ResponseWriter, r *http.Request) error <span class="cov8" title="1">{
        devices, err := h.deviceRepo.List(r.Context())
        if err != nil </span><span class="cov8" title="1">{
                jsonw.Error(w, err.Error(), nil, http.StatusInternalServerError)
                return fmt.Errorf("%v - %v", ErrListDevices, err)
        }</span>
        <span class="cov8" title="1">jsonw.Success(w, devices, http.StatusOK)
        return nil</span>
}

func (h *DeviceHandler) GetDevice(w http.ResponseWriter, r *http.Request) error <span class="cov8" title="1">{
        id := r.PathValue("id")
        device, err := h.deviceRepo.GetByID(r.Context(), id)
        if err != nil </span><span class="cov8" title="1">{
                jsonw.Error(w, "device not found", nil, http.StatusNotFound)
                return fmt.Errorf("%v - %v", ErrListDevices, err)
        }</span>
        <span class="cov8" title="1">jsonw.Success(w, device, http.StatusOK)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        "net/http"

        "github.com/piotrklosek/signing-service-challenge-go/internal/utils/jsonw"
)

type HealthHandler struct{}

type HealthResponse struct {
        Status  string `json:"status"`
        Version string `json:"version"`
}

func NewHealthHandler() *HealthHandler <span class="cov0" title="0">{
        return &amp;HealthHandler{}
}</span>

// Health evaluates the health of the service and writes a standardized response.
func (h *HealthHandler) Health(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        health := HealthResponse{
                Status:  "pass",
                Version: "v1",
        }
        jsonw.Success(w, health, http.StatusOK)

}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "time"

        "github.com/google/uuid"
        "github.com/piotrklosek/signing-service-challenge-go/internal/domain"
        "github.com/piotrklosek/signing-service-challenge-go/internal/persistence"
        "github.com/piotrklosek/signing-service-challenge-go/internal/utils/jsonw"
)

// SignatureHandler represents object used to create signatures
type SignatureHandler struct {
        signatureRepo persistence.SignatureRepository
        deviceRepo    persistence.DeviceRepository
}

// NewSignatureHandler used to create signature handler
func NewSignatureHandler(signatureRepo persistence.SignatureRepository, deviceRepo persistence.DeviceRepository) *SignatureHandler <span class="cov0" title="0">{
        return &amp;SignatureHandler{signatureRepo: signatureRepo, deviceRepo: deviceRepo}
}</span>

type SignTransactionRequest struct {
        Data string `json:"data"`
}

// SignTransactionData and return signature and signed data, and updates devices details about signatures
func (h *SignatureHandler) SignTransactionData(w http.ResponseWriter, r *http.Request) error <span class="cov0" title="0">{
        deviceID := r.PathValue("id")
        device, err := h.deviceRepo.GetByID(r.Context(), deviceID)
        if err != nil </span><span class="cov0" title="0">{
                jsonw.Error(w, "device not found", nil, http.StatusNotFound)
                return err
        }</span>

        <span class="cov0" title="0">var req SignTransactionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                jsonw.Error(w, "invalid json", nil, http.StatusBadRequest)
                return err
        }</span>

        // sign data using domain logic
        <span class="cov0" title="0">signedData, signature, err := domain.SignData(device, req.Data)
        if err != nil </span><span class="cov0" title="0">{
                jsonw.Error(w, "signing failed: "+err.Error(), nil, http.StatusInternalServerError)
                return err
        }</span>

        // createding and saving signature record details
        <span class="cov0" title="0">record := &amp;domain.SignatureRecord{
                ID:         uuid.NewString(),
                DeviceID:   device.ID,
                SignedData: signedData,
                Signature:  signature,
                CreatedAt:  time.Now(),
        }
        if err := h.signatureRepo.Create(r.Context(), record); err != nil </span><span class="cov0" title="0">{
                jsonw.Error(w, err.Error(), nil, http.StatusInternalServerError)
                return err
        }</span>

        // update device counter and last signature
        <span class="cov0" title="0">device.SignatureCounter++
        device.LastSignature = signature
        device.UpdatedAt = time.Now()
        if err := h.deviceRepo.Update(r.Context(), device); err != nil </span><span class="cov0" title="0">{
                jsonw.Error(w, "failed to update device counter", nil, http.StatusInternalServerError)
                return err
        }</span>

        <span class="cov0" title="0">jsonw.Success(w, map[string]string{
                "signature":   signature,
                "signed_data": signedData,
        }, http.StatusCreated)

        return nil</span>
}

// ListSignatures used to list all signatures recorded in system
func (h *SignatureHandler) ListSignatures(w http.ResponseWriter, r *http.Request) error <span class="cov0" title="0">{
        deviceID := r.PathValue("id")

        records, err := h.signatureRepo.ListByDevice(r.Context(), deviceID)
        if err != nil </span><span class="cov0" title="0">{
                jsonw.Error(w, err.Error(), nil, http.StatusInternalServerError)
                return err
        }</span>
        <span class="cov0" title="0">jsonw.Success(w, records, http.StatusOK)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "time"

        "github.com/google/uuid"
        "github.com/piotrklosek/signing-service-challenge-go/internal/domain"
        "github.com/piotrklosek/signing-service-challenge-go/internal/persistence"
        "github.com/piotrklosek/signing-service-challenge-go/internal/utils/jsonw"
        "github.com/piotrklosek/signing-service-challenge-go/internal/validation"
)

type UserHandler struct {
        userRepo persistence.UserRepository
}

func NewUserHandler(userRepo persistence.UserRepository) *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{userRepo: userRepo}
}</span>

type CreateUserRequest struct {
        Name  string `json:"name" validate:"required,min=3"`
        Email string `json:"email" validate:"required,email"`
}

type ListUserRequest struct{}
type ListUsersResponse struct {
        Users []domain.User `json:"users"`
}

func (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) error <span class="cov0" title="0">{
        var req CreateUserRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                jsonw.Error(w, "invalid json", nil, http.StatusBadRequest)
                return err
        }</span>
        <span class="cov0" title="0">if err := validation.ValidateStruct(&amp;req); err != nil </span><span class="cov0" title="0">{
                jsonw.Error(w, err.Error(), nil, http.StatusBadRequest)
                return err
        }</span>

        <span class="cov0" title="0">user := &amp;domain.User{
                ID:        uuid.NewString(),
                Name:      req.Name,
                Email:     req.Email,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }

        if err := h.userRepo.Create(r.Context(), user); err != nil </span><span class="cov0" title="0">{
                jsonw.Error(w, err.Error(), nil, http.StatusInternalServerError)
                return err
        }</span>

        <span class="cov0" title="0">jsonw.Success(w, user, http.StatusCreated)
        return nil</span>
}

func (h *UserHandler) ListUsers(w http.ResponseWriter, r *http.Request) error <span class="cov0" title="0">{
        users, err := h.userRepo.List(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                jsonw.Error(w, err.Error(), nil, http.StatusInternalServerError)
                return err
        }</span>
        <span class="cov0" title="0">jsonw.Success(w, users, http.StatusOK)
        return nil</span>
}

func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) error <span class="cov0" title="0">{
        id := r.PathValue("id")
        user, err := h.userRepo.GetByID(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                jsonw.Error(w, "user not found", nil, http.StatusNotFound)
                return err
        }</span>
        <span class="cov0" title="0">jsonw.Success(w, user, http.StatusOK)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package api

import (
        "context"
        "math/rand"
        "net"
        "net/http"
        "time"

        "go.uber.org/zap"
)

// create type to avoid collision
type jtwKey string
type loggerKey string
type reqID string

const (
        JWTDataKey jtwKey    = "JWTData"
        LoggerKey  loggerKey = "Logger"
        RequestID  reqID     = "reqID"
)

type JWTData struct {
        Email string `json:"email"`
        Role  string `json:"role"`
}

type apiHandlerFunc func(w http.ResponseWriter, r *http.Request) (interface{}, error)

func errorCheckerMiddleware(f func(http.ResponseWriter, *http.Request) (interface{}, error)) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                _, err := f(w, r)
                // handle error for handlers
                if err != nil </span>{<span class="cov0" title="0">

                }</span>
        }
}

func WithJWTData(ctx context.Context, v *JWTData) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, JWTDataKey, v)
}</span>

func GetJWTData(ctx context.Context) *JWTData <span class="cov0" title="0">{
        return ctx.Value(JWTDataKey).(*JWTData)
}</span>

func WithLogger(ctx context.Context, v *zap.Logger) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, LoggerKey, v)
}</span>

func GetLoger(ctx context.Context) *zap.Logger <span class="cov0" title="0">{
        return ctx.Value(LoggerKey).(*zap.Logger)
}</span>

func middleware(logger *zap.Logger, fn func(http.ResponseWriter, *http.Request) error) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()
                reqID := genRequestID()
                ip := clientIP(r)

                // propagate context with request ID
                ctx := context.WithValue(r.Context(), RequestID, reqID)
                r = r.WithContext(ctx)

                err := fn(w, r)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("HTTP_REQUEST_ERROR",
                                zap.String("request_id", reqID),
                                zap.String("method", r.Method),
                                zap.String("route", r.URL.Path),
                                zap.String("ip", ip),
                                zap.Error(err),
                                zap.Duration("latency", time.Since(start)),
                        )
                        return
                }</span>

                // // TODO: custom response encoder — np. JSON
                // if result != nil {
                //         _ = json.NewEncoder(w).Encode(result)
                // }

                // log successful request
                <span class="cov0" title="0">logger.Info("HTTP_REQUEST",
                        zap.String("request_id", reqID),
                        zap.String("method", r.Method),
                        zap.String("route", r.URL.Path),
                        zap.String("ip", ip),
                        zap.Duration("latency", time.Since(start)),
                )</span>
        })
}

func clientIP(r *http.Request) string <span class="cov0" title="0">{
        if ip := r.Header.Get("X-Forwarded-For"); ip != "" </span><span class="cov0" title="0">{
                return ip
        }</span>
        <span class="cov0" title="0">host, _, err := net.SplitHostPort(r.RemoteAddr)
        if err != nil </span><span class="cov0" title="0">{
                return r.RemoteAddr
        }</span>
        <span class="cov0" title="0">return host</span>
}

func genRequestID() string <span class="cov0" title="0">{
        const letters = "abcdefghijklmnopqrstuvwxyz0123456789"
        b := make([]byte, 8)
        for i := range b </span><span class="cov0" title="0">{
                b[i] = letters[rand.Intn(len(letters))]
        }</span>
        <span class="cov0" title="0">return string(b)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package api

import (
        "net/http"

        "github.com/piotrklosek/signing-service-challenge-go/internal/api/handlers"
        "github.com/piotrklosek/signing-service-challenge-go/internal/persistence"
        "github.com/piotrklosek/signing-service-challenge-go/internal/utils/logger"
)

// TODO move handlers to separeted packages, so every handler can have different set of errors
// NewRouter creates HTTP router with endpoints
func NewRouter(
        deviceRepo persistence.DeviceRepository,
        signatureRepo persistence.SignatureRepository,
        userRepo persistence.UserRepository,
) http.Handler <span class="cov0" title="0">{

        mux := http.NewServeMux()
        apiLogger := logger.CreateLogger("api")

        // Handlers
        healthHandler := handlers.NewHealthHandler()
        deviceHandler := handlers.NewDeviceHandler(deviceRepo, userRepo)
        signatureHandler := handlers.NewSignatureHandler(signatureRepo, deviceRepo)
        userHandler := handlers.NewUserHandler(userRepo)

        // Devices
        mux.Handle("POST /api/v1/devices", middleware(apiLogger, deviceHandler.CreateDevice))
        mux.Handle("GET /api/v1/devices", middleware(apiLogger, deviceHandler.ListDevices))
        mux.Handle("GET /api/v1/devices/{id}", middleware(apiLogger, deviceHandler.GetDevice))

        // Signatures
        mux.Handle("POST /api/v1/devices/{id}/sign", middleware(apiLogger, signatureHandler.SignTransactionData))
        mux.Handle("GET /api/v1/devices/{id}/signatures", middleware(apiLogger, signatureHandler.ListSignatures))

        // Users as an extra for user management
        mux.Handle("POST /api/v1/users", middleware(apiLogger, userHandler.CreateUser))
        mux.Handle("GET /api/v1/users", middleware(apiLogger, userHandler.ListUsers))
        mux.Handle("GET /api/v1/users/{id}", middleware(apiLogger, userHandler.GetUser))

        // Health
        mux.HandleFunc("GET /health", healthHandler.Health)

        // TODO wrap endpoints with auth middleware for only admin access

        return mux
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package config

import (
        "log"

        "github.com/spf13/viper"
)

// Config holds config struct
type Config struct {
        Port     string `env:"SIG_PORT"`
        DBType   string `env:"SIG_DB_TYPE"` // memory | postgres | mongo
        Postgres struct {
                DSN string `env:"SIG_DB_POSTGRES_DSN"`
        }
        Mongo struct {
                URI      string `env:"SIG_DB_MONGO_URI"`
                Database string `env:"SIG_DB_MONGO_DATABASE"`
        }
        InMemory struct {
                DBFilePath string `env:"SIG_DB_MEMORY_FILE"`
        }
}

// Load config values from env and config file
func Load() Config <span class="cov0" title="0">{
        var cfg Config

        cfg.Port = viper.GetString("port")
        cfg.DBType = viper.GetString("db.type")

        // database connectors configs
        cfg.Postgres.DSN = viper.GetString("db.postgres.dsn")

        cfg.Mongo.URI = viper.GetString("db.mongo.uri")
        cfg.Mongo.Database = viper.GetString("db.mongo.database")

        cfg.InMemory.DBFilePath = viper.GetString("db.inmemory.dbfilepath")

        if err := viper.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error parsing config: %v", err)
        }</span>

        <span class="cov0" title="0">return cfg</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package domain

import (
        "errors"
        "time"

        "github.com/piotrklosek/signing-service-challenge-go/internal/utils/crypto"
)

// AlgorithmType supported alrorithm
type AlgorithmType string

const (
        AlgorithmRSA AlgorithmType = "RSA"
        AlgorithmECC AlgorithmType = "ECC"
)

// SignatureDevice represent signature device
type SignatureDevice struct {
        ID               string        `json:"id"`
        UserID           string        `json:"user_id"`
        Algorithm        AlgorithmType `json:"algorithm"`
        Label            string        `json:"label,omitempty"`
        PublicKey        []byte        `json:"public_key"`
        PrivateKey       []byte        `json:"-"`
        SignatureCounter uint64        `json:"signature_counter"`
        LastSignature    string        `json:"last_signature"`
        CreatedAt        time.Time     `json:"created_at"`
        UpdatedAt        time.Time     `json:"updated_at"`
}

// GenerateKeys generate pair of keys based on choosen algorithm
func (d *SignatureDevice) GenerateKeys() error <span class="cov8" title="1">{
        switch d.Algorithm </span>{
        case AlgorithmRSA:<span class="cov8" title="1">
                gen := crypto.RSAGenerator{}
                marshaler := crypto.NewRSAMarshaler()

                keyPair, err := gen.Generate()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">pub, priv, err := marshaler.Marshal(*keyPair)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">d.PublicKey = pub
                d.PrivateKey = priv</span>

        case AlgorithmECC:<span class="cov8" title="1">
                gen := crypto.ECCGenerator{}
                marshaler := crypto.NewECCMarshaler()

                keyPair, err := gen.Generate()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">pub, priv, err := marshaler.Encode(*keyPair)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">d.PublicKey = pub
                d.PrivateKey = priv</span>

        default:<span class="cov8" title="1">
                return errors.New("unsupported algorithm: " + string(d.Algorithm))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// IncrementCounter used to increment signed docs by device and record last signed time
func (d *SignatureDevice) IncrementCounter(newLastSignature string) <span class="cov8" title="1">{
        d.SignatureCounter++
        d.LastSignature = newLastSignature
        d.UpdatedAt = time.Now()
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package domain

import (
        "encoding/base64"
        "fmt"
        "time"
)

// SignatureRecord represents single signature generated by device
type SignatureRecord struct {
        ID         string    `json:"id"`
        DeviceID   string    `json:"device_id"`
        SignedData string    `json:"signed_data"`
        Signature  string    `json:"signature"`
        CreatedAt  time.Time `json:"created_at"`
}

// PrepareSignedData creates signed string &lt;counter&gt;_&lt;data&gt;_&lt;last_signature&gt;
func PrepareSignedData(device *SignatureDevice, data string) string <span class="cov8" title="1">{
        lastSignature := device.LastSignature
        if device.SignatureCounter == 0 </span><span class="cov8" title="1">{
                // base64(device.id) return if first signature
                lastSignature = base64.StdEncoding.EncodeToString([]byte(device.ID))
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%d_%s_%s", device.SignatureCounter, data, lastSignature)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package domain

import (
        "encoding/base64"
        "errors"

        "github.com/piotrklosek/signing-service-challenge-go/internal/utils/crypto"
)

// SignData business logic for signing data
func SignData(device *SignatureDevice, data string) (signedData string, signature string, err error) <span class="cov8" title="1">{
        signedData = PrepareSignedData(device, data)

        var s crypto.Signer
        switch device.Algorithm </span>{
        case AlgorithmRSA:<span class="cov8" title="1">
                s, err = crypto.NewRSASigner(device.PrivateKey)</span>
        case AlgorithmECC:<span class="cov8" title="1">
                s, err = crypto.NewECCSigner(device.PrivateKey)</span>
        default:<span class="cov8" title="1">
                return "", "", errors.New("unsupported algorithm")</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">sigBytes, err := s.Sign([]byte(signedData))
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        // base64-encode signature
        <span class="cov8" title="1">signature = base64.StdEncoding.EncodeToString(sigBytes)

        return signedData, signature, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package inmemory

import (
        "context"
        "errors"
        "sync"

        "github.com/piotrklosek/signing-service-challenge-go/internal/domain"
)

type deviceRepo struct {
        mu         sync.RWMutex
        deviceData map[string]*domain.SignatureDevice
}

func NewDeviceRepo() *deviceRepo <span class="cov0" title="0">{
        return &amp;deviceRepo{deviceData: make(map[string]*domain.SignatureDevice)}
}</span>

func (r *deviceRepo) Create(ctx context.Context, d *domain.SignatureDevice) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        if _, exists := r.deviceData[d.ID]; exists </span><span class="cov0" title="0">{
                return errors.New("device already exists")
        }</span>
        <span class="cov0" title="0">r.deviceData[d.ID] = d
        return nil</span>
}

func (r *deviceRepo) GetByID(ctx context.Context, id string) (*domain.SignatureDevice, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        d, ok := r.deviceData[id]
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("device not found")
        }</span>
        <span class="cov0" title="0">return d, nil</span>
}

func (r *deviceRepo) List(ctx context.Context) ([]*domain.SignatureDevice, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        var list []*domain.SignatureDevice
        for _, d := range r.deviceData </span><span class="cov0" title="0">{
                list = append(list, d)
        }</span>
        <span class="cov0" title="0">return list, nil</span>
}

func (r *deviceRepo) Update(ctx context.Context, d *domain.SignatureDevice) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        if _, ok := r.deviceData[d.ID]; !ok </span><span class="cov0" title="0">{
                return errors.New("device not found")
        }</span>
        <span class="cov0" title="0">r.deviceData[d.ID] = d
        return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package inmemory

import (
        "context"
        "encoding/json"
        "errors"
        "os"
        "sync"

        "github.com/piotrklosek/signing-service-challenge-go/internal/domain"
)

// MemoryStore represents inmemory layer object to enable saving/loading data
type MemoryStore struct {
        UserRepo      *userRepo
        DeviceRepo    *deviceRepo
        SignatureRepo *signatureRepo

        mu     sync.RWMutex
        dbFile string
}

// NewMemoryStore create a new inmemory layer, if previous dbfile exist loads data
func NewMemoryStore(dbFile string) (*MemoryStore, error) <span class="cov0" title="0">{
        store := &amp;MemoryStore{
                UserRepo:      NewUserRepo(),
                DeviceRepo:    NewDeviceRepo(),
                SignatureRepo: NewSignatureRepo(),
                dbFile:        dbFile,
        }

        if dbFile != "" </span><span class="cov0" title="0">{
                if err := store.Load(); err != nil &amp;&amp; !errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return store, nil</span>
}

// Save dump inmemory layer into json file
func (s *MemoryStore) Save() error <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        dump := struct {
                Users      map[string]*domain.User              `json:"users"`
                Devices    map[string]*domain.SignatureDevice   `json:"devices"`
                Signatures map[string][]*domain.SignatureRecord `json:"signatures"`
        }{
                Users:      s.UserRepo.userData,
                Devices:    s.DeviceRepo.deviceData,
                Signatures: s.SignatureRepo.signaturesData,
        }

        data, err := json.MarshalIndent(dump, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.WriteFile(s.dbFile, data, 0644)</span>
}

// Load dumped data into inmemory layer
func (s *MemoryStore) Load() error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        data, err := os.ReadFile(s.dbFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var dump struct {
                Users      map[string]*domain.User              `json:"users"`
                Devices    map[string]*domain.SignatureDevice   `json:"devices"`
                Signatures map[string][]*domain.SignatureRecord `json:"signatures"`
        }
        if err := json.Unmarshal(data, &amp;dump); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.UserRepo.userData = dump.Users
        s.DeviceRepo.deviceData = dump.Devices
        s.SignatureRepo.signaturesData = dump.Signatures

        return nil</span>
}

// SaveOnShutdown triggers saving data of inmemory persistence layer
func (s *MemoryStore) SaveOnShutdown(ctx context.Context) <span class="cov0" title="0">{
        &lt;-ctx.Done()
        _ = s.Save()
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package inmemory

import (
        "context"
        "errors"
        "sync"

        "github.com/piotrklosek/signing-service-challenge-go/internal/domain"
)

type signatureRepo struct {
        mu             sync.RWMutex
        signaturesData map[string][]*domain.SignatureRecord // deviceID -&gt; list of signatures
}

func NewSignatureRepo() *signatureRepo <span class="cov0" title="0">{
        return &amp;signatureRepo{signaturesData: make(map[string][]*domain.SignatureRecord)}
}</span>

func (r *signatureRepo) Create(ctx context.Context, s *domain.SignatureRecord) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        if s.DeviceID == "" </span><span class="cov0" title="0">{
                return errors.New("signature must have device id")
        }</span>
        <span class="cov0" title="0">r.signaturesData[s.DeviceID] = append(r.signaturesData[s.DeviceID], s)
        return nil</span>
}

func (r *signatureRepo) ListByDevice(ctx context.Context, deviceID string) ([]*domain.SignatureRecord, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return r.signaturesData[deviceID], nil
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package inmemory

import (
        "context"
        "errors"
        "sync"

        "github.com/piotrklosek/signing-service-challenge-go/internal/domain"
)

type userRepo struct {
        mu       sync.RWMutex
        userData map[string]*domain.User
}

func NewUserRepo() *userRepo <span class="cov0" title="0">{
        return &amp;userRepo{userData: make(map[string]*domain.User)}
}</span>

func (r *userRepo) Create(ctx context.Context, u *domain.User) error <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        if _, exists := r.userData[u.ID]; exists </span><span class="cov0" title="0">{
                return errors.New("user already exists")
        }</span>
        <span class="cov0" title="0">r.userData[u.ID] = u
        return nil</span>
}

func (r *userRepo) GetByID(ctx context.Context, id string) (*domain.User, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        u, ok := r.userData[id]
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("user not found")
        }</span>
        <span class="cov0" title="0">return u, nil</span>
}

func (r *userRepo) GetByEmail(ctx context.Context, email string) (*domain.User, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        for _, u := range r.userData </span><span class="cov0" title="0">{
                if u.Email == email </span><span class="cov0" title="0">{
                        return u, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, errors.New("user not found")</span>
}

func (r *userRepo) List(ctx context.Context) ([]*domain.User, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        var list []*domain.User
        for _, u := range r.userData </span><span class="cov0" title="0">{
                list = append(list, u)
        }</span>
        <span class="cov0" title="0">return list, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package mongo

import (
        "context"

        "github.com/piotrklosek/signing-service-challenge-go/internal/domain"
        "gopkg.in/mgo.v2"
)

const deviceCollectioName = "device"

type deviceRepo struct {
        sess         *mgo.Session
        databaseName string
}

func NewDeviceRepo(sess *mgo.Session, databaseName string) (*deviceRepo, error) <span class="cov0" title="0">{
        c := sess.DB(databaseName).C(userCollectioName)
        key := "device_uuid"
        index := mgo.Index{
                Key:        []string{key},
                Unique:     true,
                DropDups:   true,
                Background: true,
                Sparse:     true,
        }
        if err := c.EnsureIndex(index); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;deviceRepo{
                sess:         sess,
                databaseName: databaseName,
        }, nil</span>
}

func (r *deviceRepo) Create(ctx context.Context, d *domain.SignatureDevice) error <span class="cov0" title="0">{
        panic("implement me")</span>
}
func (r *deviceRepo) GetByID(ctx context.Context, id string) (*domain.SignatureDevice, error) <span class="cov0" title="0">{
        panic("implement me")</span>
}
func (r *deviceRepo) List(ctx context.Context) ([]*domain.SignatureDevice, error) <span class="cov0" title="0">{
        panic("implement me")</span>
}
func (r *deviceRepo) Update(ctx context.Context, d *domain.SignatureDevice) error <span class="cov0" title="0">{
        panic("implement me")</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package mongo

import (
        "fmt"

        "github.com/piotrklosek/signing-service-challenge-go/internal/persistence"
        "gopkg.in/mgo.v2"
)

type MongoStore struct {
        session *mgo.Session
}

func NewStore(dbUri string) (*MongoStore, error) <span class="cov0" title="0">{
        session, err := mgo.Dial(dbUri)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open mongo connection: %w", err)
        }</span>

        <span class="cov0" title="0">if err := session.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping mongo: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;MongoStore{
                session: session,
        }, nil</span>
}

func (s *MongoStore) Close() error <span class="cov0" title="0">{
        return s.Close()
}</span>

func NewRepositories(dbUri, databaseName string) (
        persistence.DeviceRepository,
        persistence.SignatureRepository,
        persistence.UserRepository,
        error) <span class="cov0" title="0">{

        store, err := NewStore(dbUri)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        <span class="cov0" title="0">device, err := NewDeviceRepo(store.session, databaseName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("error while creating device repository for mongo driver :%v\n", err)
        }</span>

        <span class="cov0" title="0">user, err := NewUserRepo(store.session, databaseName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("error while creating user repository for mongo driver :%v\n", err)
        }</span>

        <span class="cov0" title="0">signature, err := NewSignatureRepo(store.session, databaseName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("error while creating signature repository for mongo driver :%v\n", err)
        }</span>

        <span class="cov0" title="0">return device, signature, user, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package mongo

import (
        "context"

        "github.com/piotrklosek/signing-service-challenge-go/internal/domain"
        "gopkg.in/mgo.v2"
)

const signatureCollectioName = "signature"

type signatureRepo struct {
        sess         *mgo.Session
        databaseName string
}

func NewSignatureRepo(sess *mgo.Session, databaseName string) (*signatureRepo, error) <span class="cov0" title="0">{
        c := sess.DB(databaseName).C(userCollectioName)
        key := "signature_uuid"
        index := mgo.Index{
                Key:        []string{key},
                Unique:     true,
                DropDups:   true,
                Background: true,
                Sparse:     true,
        }
        if err := c.EnsureIndex(index); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;signatureRepo{
                sess:         sess,
                databaseName: databaseName,
        }, nil</span>
}

func (r *signatureRepo) Create(ctx context.Context, s *domain.SignatureRecord) error <span class="cov0" title="0">{
        panic("implement me")</span>
}

func (r *signatureRepo) ListByDevice(ctx context.Context, deviceID string) ([]*domain.SignatureRecord, error) <span class="cov0" title="0">{
        panic("implement me")</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package mongo

import (
        "context"

        "github.com/piotrklosek/signing-service-challenge-go/internal/domain"
        "gopkg.in/mgo.v2"
)

const userCollectioName = "user"

type userRepo struct {
        sess         *mgo.Session
        databaseName string
}

func NewUserRepo(sess *mgo.Session, databaseName string) (*userRepo, error) <span class="cov0" title="0">{
        c := sess.DB(databaseName).C(userCollectioName)
        key := "user_uuid"
        index := mgo.Index{
                Key:        []string{key},
                Unique:     true,
                DropDups:   true,
                Background: true,
                Sparse:     true,
        }
        if err := c.EnsureIndex(index); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;userRepo{
                sess:         sess,
                databaseName: databaseName,
        }, nil</span>
}

func (r *userRepo) Create(ctx context.Context, u *domain.User) error <span class="cov0" title="0">{
        panic("implement me")</span>
}

func (r *userRepo) GetByID(ctx context.Context, id string) (*domain.User, error) <span class="cov0" title="0">{
        panic("implement me")</span>
}

func (r *userRepo) GetByEmail(ctx context.Context, email string) (*domain.User, error) <span class="cov0" title="0">{
        panic("implement me")</span>
}

func (r *userRepo) List(ctx context.Context) ([]*domain.User, error) <span class="cov0" title="0">{
        panic("implement me")</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package postgres

import (
        "context"
        "database/sql"

        "github.com/piotrklosek/signing-service-challenge-go/internal/domain"
)

type deviceRepo struct {
        db *sql.DB
}

func NewDeviceRepo(db *sql.DB) *deviceRepo <span class="cov0" title="0">{
        return &amp;deviceRepo{db: db}
}</span>

func (r *deviceRepo) Create(ctx context.Context, d *domain.SignatureDevice) error <span class="cov0" title="0">{
        _, err := r.db.ExecContext(ctx,
                `INSERT INTO signature_devices
        (id, user_id, algorithm, label, public_key, private_key,
         signature_counter, last_signature, created_at, updated_at)
         VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10)`,
                d.ID, d.UserID, d.Algorithm, d.Label, d.PublicKey, d.PrivateKey,
                d.SignatureCounter, d.LastSignature, d.CreatedAt, d.UpdatedAt,
        )
        return err
}</span>

func (r *deviceRepo) GetByID(ctx context.Context, id string) (*domain.SignatureDevice, error) <span class="cov0" title="0">{
        row := r.db.QueryRowContext(ctx,
                `SELECT id, user_id, algorithm, label, public_key, private_key,
                signature_counter, last_signature, created_at, updated_at
         FROM signature_devices WHERE id=$1`, id)

        var d domain.SignatureDevice
        if err := row.Scan(
                &amp;d.ID, &amp;d.UserID, &amp;d.Algorithm, &amp;d.Label, &amp;d.PublicKey, &amp;d.PrivateKey,
                &amp;d.SignatureCounter, &amp;d.LastSignature, &amp;d.CreatedAt, &amp;d.UpdatedAt,
        ); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;d, nil</span>
}

func (r *deviceRepo) List(ctx context.Context) ([]*domain.SignatureDevice, error) <span class="cov0" title="0">{
        rows, err := r.db.QueryContext(ctx,
                `SELECT id, user_id, algorithm, label, public_key, private_key,
                signature_counter, last_signature, created_at, updated_at
         FROM signature_devices ORDER BY created_at DESC`)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var devices []*domain.SignatureDevice
        for rows.Next() </span><span class="cov0" title="0">{
                var d domain.SignatureDevice
                if err := rows.Scan(
                        &amp;d.ID, &amp;d.UserID, &amp;d.Algorithm, &amp;d.Label, &amp;d.PublicKey, &amp;d.PrivateKey,
                        &amp;d.SignatureCounter, &amp;d.LastSignature, &amp;d.CreatedAt, &amp;d.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">devices = append(devices, &amp;d)</span>
        }
        <span class="cov0" title="0">return devices, nil</span>
}

func (r *deviceRepo) Update(ctx context.Context, d *domain.SignatureDevice) error <span class="cov0" title="0">{
        _, err := r.db.ExecContext(ctx,
                `UPDATE signature_devices
         SET algorithm=$2, label=$3, public_key=$4, private_key=$5,
             signature_counter=$6, last_signature=$7, updated_at=$8
         WHERE id=$1`,
                d.ID, d.Algorithm, d.Label, d.PublicKey, d.PrivateKey,
                d.SignatureCounter, d.LastSignature, d.UpdatedAt,
        )
        return err
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "fmt"

        _ "github.com/lib/pq"
        "github.com/piotrklosek/signing-service-challenge-go/internal/persistence"
)

// PostgresStore used to store database reference
type PostgresStore struct {
        db *sql.DB
}

// NewStore create new postgress connection to use in repositories
func NewStore(dsn string) (*PostgresStore, error) <span class="cov0" title="0">{
        db, err := sql.Open("postgres", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open postgres connection: %w", err)
        }</span>

        <span class="cov0" title="0">if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping postgres: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;PostgresStore{db: db}, nil</span>
}

// Close use to close database connection
func (s *PostgresStore) Close() error <span class="cov0" title="0">{
        return s.db.Close()
}</span>

// NewRepositories used to create repositories for postgres database connector
func NewRepositories(dsn string) (
        persistence.DeviceRepository,
        persistence.SignatureRepository,
        persistence.UserRepository,
        error,
) <span class="cov0" title="0">{
        store, err := NewStore(dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        <span class="cov0" title="0">deviceRepo := NewDeviceRepo(store.db)
        signatureRepo := NewSignatureRepo(store.db)
        userRepo := NewUserRepo(store.db)

        return deviceRepo, signatureRepo, userRepo, nil</span>
}

// TODO move into migrations to use golang migration tool
// RunMigrations used to create database schema at the start of app
func RunMigrations(dsn string) error <span class="cov0" title="0">{
        db, err := sql.Open("postgres", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer db.Close()

        queries := []string{
                `CREATE TABLE IF NOT EXISTS users (
                        id UUID PRIMARY KEY,
                        name TEXT NOT NULL,
                        email TEXT UNIQUE NOT NULL,
                        created_at TIMESTAMP NOT NULL,
                        updated_at TIMESTAMP NOT NULL
                );`,

                `CREATE TABLE IF NOT EXISTS signature_devices (
                        id UUID PRIMARY KEY,
                        user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
                        algorithm TEXT NOT NULL,
                        label TEXT,
                        public_key TEXT,
                        private_key TEXT,
                        signature_counter BIGINT NOT NULL DEFAULT 0,
                        last_signature TEXT,
                        created_at TIMESTAMP NOT NULL,
                        updated_at TIMESTAMP NOT NULL
                );`,

                `CREATE TABLE IF NOT EXISTS signatures (
                        id UUID PRIMARY KEY,
                        device_id UUID NOT NULL REFERENCES signature_devices(id) ON DELETE CASCADE,
                        signed_data TEXT NOT NULL,
                        signature TEXT NOT NULL,
                        created_at TIMESTAMP NOT NULL
                );`,
        }

        for _, q := range queries </span><span class="cov0" title="0">{
                if _, err := db.ExecContext(context.Background(), q); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("migration failed: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package postgres

import (
        "context"
        "database/sql"

        "github.com/piotrklosek/signing-service-challenge-go/internal/domain"
)

type signatureRepo struct {
        db *sql.DB
}

// NewSignatureRepo create interface for signature database
func NewSignatureRepo(db *sql.DB) *signatureRepo <span class="cov0" title="0">{
        return &amp;signatureRepo{db: db}
}</span>

// Create used to create new signature record
func (r *signatureRepo) Create(ctx context.Context, s *domain.SignatureRecord) error <span class="cov0" title="0">{
        _, err := r.db.ExecContext(ctx,
                `INSERT INTO signatures (id, device_id, signed_data, signature, created_at)
         VALUES ($1,$2,$3,$4,$5)`,
                s.ID, s.DeviceID, s.SignedData, s.Signature, s.CreatedAt,
        )
        return err
}</span>

// ListByDevice used to return all signature record by deviceID
func (r *signatureRepo) ListByDevice(ctx context.Context, deviceID string) ([]*domain.SignatureRecord, error) <span class="cov0" title="0">{
        rows, err := r.db.QueryContext(ctx,
                `SELECT id, device_id, signed_data, signature, created_at
         FROM signatures WHERE device_id=$1 ORDER BY created_at ASC`, deviceID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var records []*domain.SignatureRecord
        for rows.Next() </span><span class="cov0" title="0">{
                var s domain.SignatureRecord
                if err := rows.Scan(&amp;s.ID, &amp;s.DeviceID, &amp;s.SignedData, &amp;s.Signature, &amp;s.CreatedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">records = append(records, &amp;s)</span>
        }
        <span class="cov0" title="0">return records, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package postgres

import (
        "context"
        "database/sql"

        "github.com/piotrklosek/signing-service-challenge-go/internal/domain"
)

type userRepo struct {
        db *sql.DB
}

// NewUSerRepo create interface for user database
func NewUserRepo(db *sql.DB) *userRepo <span class="cov0" title="0">{
        return &amp;userRepo{db: db}
}</span>

// Create method used to created row object in with user
func (r *userRepo) Create(ctx context.Context, u *domain.User) error <span class="cov0" title="0">{
        _, err := r.db.ExecContext(ctx,
                `INSERT INTO users (id, name, email, created_at, updated_at)
         VALUES ($1, $2, $3, $4, $5)`,
                u.ID, u.Name, u.Email, u.CreatedAt, u.UpdatedAt,
        )
        return err
}</span>

// GetByID used to return user by ID
func (r *userRepo) GetByID(ctx context.Context, id string) (*domain.User, error) <span class="cov0" title="0">{
        row := r.db.QueryRowContext(ctx,
                `SELECT id, name, email, created_at, updated_at FROM users WHERE id=$1`, id)
        var u domain.User
        if err := row.Scan(&amp;u.ID, &amp;u.Name, &amp;u.Email, &amp;u.CreatedAt, &amp;u.UpdatedAt); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;u, nil</span>
}

// GetByEmail used to return user by email
func (r *userRepo) GetByEmail(ctx context.Context, email string) (*domain.User, error) <span class="cov0" title="0">{
        row := r.db.QueryRowContext(ctx,
                `SELECT id, name, email, created_at, updated_at FROM users WHERE email=$1`, email)
        var u domain.User
        if err := row.Scan(&amp;u.ID, &amp;u.Name, &amp;u.Email, &amp;u.CreatedAt, &amp;u.UpdatedAt); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;u, nil</span>
}

// List used to return all user list
func (r *userRepo) List(ctx context.Context) ([]*domain.User, error) <span class="cov0" title="0">{
        rows, err := r.db.QueryContext(ctx,
                `SELECT id, name, email, created_at, updated_at FROM users ORDER BY created_at DESC`)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var users []*domain.User
        for rows.Next() </span><span class="cov0" title="0">{
                var u domain.User
                if err := rows.Scan(&amp;u.ID, &amp;u.Name, &amp;u.Email, &amp;u.CreatedAt, &amp;u.UpdatedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">users = append(users, &amp;u)</span>
        }
        <span class="cov0" title="0">return users, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package crypto

import (
        "crypto/ecdsa"
        "crypto/x509"
        "encoding/pem"
)

// ECCKeyPair is a DTO that holds ECC private and public keys.
type ECCKeyPair struct {
        Public  *ecdsa.PublicKey
        Private *ecdsa.PrivateKey
}

// ECCMarshaler can encode and decode an ECC key pair.
type ECCMarshaler struct{}

// NewECCMarshaler creates a new ECCMarshaler.
func NewECCMarshaler() ECCMarshaler <span class="cov0" title="0">{
        return ECCMarshaler{}
}</span>

// Encode takes an ECCKeyPair and encodes it to be written on disk.
// It returns the public and the private key as a byte slice.
func (m ECCMarshaler) Encode(keyPair ECCKeyPair) ([]byte, []byte, error) <span class="cov0" title="0">{
        privateKeyBytes, err := x509.MarshalECPrivateKey(keyPair.Private)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">publicKeyBytes, err := x509.MarshalPKIXPublicKey(keyPair.Public)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">encodedPrivate := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "PRIVATE_KEY",
                Bytes: privateKeyBytes,
        })

        encodedPublic := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "PUBLIC_KEY",
                Bytes: publicKeyBytes,
        })

        return encodedPublic, encodedPrivate, nil</span>
}

// Decode assembles an ECCKeyPair from an encoded private key.
func (m ECCMarshaler) Decode(privateKeyBytes []byte) (*ECCKeyPair, error) <span class="cov0" title="0">{
        block, _ := pem.Decode(privateKeyBytes)
        privateKey, err := x509.ParseECPrivateKey(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;ECCKeyPair{
                Private: privateKey,
                Public:  &amp;privateKey.PublicKey,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package crypto

import (
        "crypto/ecdsa"
        "crypto/elliptic"
        "crypto/rand"
        "crypto/rsa"
)

// RSAGenerator generates a RSA key pair.
type RSAGenerator struct{}

// Generate generates a new RSAKeyPair.
func (g *RSAGenerator) Generate() (*RSAKeyPair, error) <span class="cov0" title="0">{
        // Security has been ignored for the sake of simplicity.
        key, err := rsa.GenerateKey(rand.Reader, 1024)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;RSAKeyPair{
                Public:  &amp;key.PublicKey,
                Private: key,
        }, nil</span>
}

// ECCGenerator generates an ECC key pair.
type ECCGenerator struct{}

// Generate generates a new ECCKeyPair.
func (g *ECCGenerator) Generate() (*ECCKeyPair, error) <span class="cov0" title="0">{
        // Security has been ignored for the sake of simplicity.
        key, err := ecdsa.GenerateKey(elliptic.P384(), rand.Reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;ECCKeyPair{
                Public:  &amp;key.PublicKey,
                Private: key,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package crypto

import (
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
)

// RSAKeyPair is a DTO that holds RSA private and public keys.
type RSAKeyPair struct {
        Public  *rsa.PublicKey
        Private *rsa.PrivateKey
}

// RSAMarshaler can encode and decode an RSA key pair.
type RSAMarshaler struct{}

// NewRSAMarshaler creates a new RSAMarshaler.
func NewRSAMarshaler() RSAMarshaler <span class="cov0" title="0">{
        return RSAMarshaler{}
}</span>

// Marshal takes an RSAKeyPair and encodes it to be written on disk.
// It returns the public and the private key as a byte slice.
func (m *RSAMarshaler) Marshal(keyPair RSAKeyPair) ([]byte, []byte, error) <span class="cov0" title="0">{
        privateKeyBytes := x509.MarshalPKCS1PrivateKey(keyPair.Private)
        publicKeyBytes := x509.MarshalPKCS1PublicKey(keyPair.Public)

        encodedPrivate := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "RSA_PRIVATE_KEY",
                Bytes: privateKeyBytes,
        })

        encodePublic := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "RSA_PUBLIC_KEY",
                Bytes: publicKeyBytes,
        })

        return encodePublic, encodedPrivate, nil
}</span>

// Unmarshal takes an encoded RSA private key and transforms it into a rsa.PrivateKey.
func (m *RSAMarshaler) Unmarshal(privateKeyBytes []byte) (*RSAKeyPair, error) <span class="cov0" title="0">{
        block, _ := pem.Decode(privateKeyBytes)
        privateKey, err := x509.ParsePKCS1PrivateKey(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;RSAKeyPair{
                Private: privateKey,
                Public:  &amp;privateKey.PublicKey,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package crypto

import (
        "crypto/ecdsa"
        "crypto/rand"
        "crypto/rsa"
        "crypto/sha256"
)

// Signer defines a contract for different types of signing implementations.
type Signer interface {
        Sign(dataToBeSigned []byte) ([]byte, error)
}

// RSASigner represents signer object
type RSASigner struct {
        PrivateKey *rsa.PrivateKey
}

// NewRSASigner creates new signer based on private key
func NewRSASigner(privateKey []byte) (*RSASigner, error) <span class="cov0" title="0">{
        m := NewRSAMarshaler()
        keyPair, err := m.Unmarshal(privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;RSASigner{PrivateKey: keyPair.Private}, nil</span>
}

// Sign provided data using RSA algorithm and return signed data
func (s *RSASigner) Sign(dataToBeSigned []byte) ([]byte, error) <span class="cov0" title="0">{
        hash := sha256.Sum256(dataToBeSigned)
        return rsa.SignPKCS1v15(rand.Reader, s.PrivateKey, 0, hash[:])
}</span>

// ECCSigner represents signer object
type ECCSigner struct {
        PrivateKey *ecdsa.PrivateKey
}

// NewECCSigner creates new signer based on private key
func NewECCSigner(privateKey []byte) (*ECCSigner, error) <span class="cov0" title="0">{
        m := NewECCMarshaler()
        keyPair, err := m.Decode(privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;ECCSigner{PrivateKey: keyPair.Private}, nil</span>
}

// Sign provided data using ECC algorithm and return signed data
func (s *ECCSigner) Sign(dataToBeSigned []byte) ([]byte, error) <span class="cov0" title="0">{
        hash := sha256.Sum256(dataToBeSigned)

        r, sigS, err := ecdsa.Sign(rand.Reader, s.PrivateKey, hash[:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">signature := append(r.Bytes(), sigS.Bytes()...)
        return signature, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package jsonw

import (
        "bytes"
        "encoding/json"
        "log"
        "net/http"
)

// Message is interface for valid JSON struct
type Message interface {
        HTTPStatus() int
}

// SuccessJSON struct contains message json format for success/fail
// For more information check:
type SuccessJSON struct {
        Status string      `json:"status"`
        Data   interface{} `json:"data"`
        Code   int         `json:"-"`
}

// HTTPStatus return http status for success response (200)
func (s SuccessJSON) HTTPStatus() int <span class="cov0" title="0">{
        return http.StatusOK
}</span>

// FailJSON struct is same what success, but with correct name in function
type FailJSON SuccessJSON

// HTTPStatus return hhtp status for fail response (200)
func (f FailJSON) HTTPStatus() int <span class="cov0" title="0">{
        return http.StatusUnprocessableEntity
}</span>

// ErrorJSON struct contains message json format for error
// For more information check:
type ErrorJSON struct {
        Status  string      `json:"status"`
        Data    interface{} `json:"data,omitempty"`
        Message interface{} `json:"message"`
        Code    int         `json:"-"`
}

// HTTPStatus return http status for error response - code value
func (s ErrorJSON) HTTPStatus() int <span class="cov0" title="0">{
        return s.Code
}</span>

// Success create json message with success status and data
func Success(w http.ResponseWriter, data interface{}, code int) <span class="cov0" title="0">{
        var json = SuccessJSON{
                Status: "success",
                Data:   data,
                Code:   code,
        }
        RespondWithJSON(w, json)
}</span>

// Fail create json message with faile status and data
func Fail(w http.ResponseWriter, data interface{}) <span class="cov0" title="0">{
        var json = FailJSON{
                Status: "fail",
                Data:   data,
        }
        RespondWithJSON(w, json)
}</span>

// FailValidation create json message with fail status and data
// contains validation with param data
func FailValidation(w http.ResponseWriter, data interface{}) <span class="cov0" title="0">{
        var json = FailJSON{
                Status: "fail",
                Data: map[string]interface{}{
                        "validation": data,
                },
        }
        RespondWithJSON(w, json)
}</span>

// Error create json message with erorr. Optional params are data and code. If
// error doesn't contains data or/and code just set nil
func Error(w http.ResponseWriter, message interface{}, data interface{}, code int) <span class="cov0" title="0">{
        var json = ErrorJSON{
                Status:  "error",
                Message: message,
                Data:    data,
                Code:    code,
        }
        RespondWithJSON(w, json)
}</span>

// RespondWithJSON sends value v as a JSON response.
func RespondWithJSON(w http.ResponseWriter, v Message) <span class="cov0" title="0">{
        buf := &amp;bytes.Buffer{}
        if err := json.NewEncoder(buf).Encode(v); err != nil </span><span class="cov0" title="0">{
                log.Print("failed to encode response as JSON: ", err)
                status := http.StatusInternalServerError
                http.Error(w, http.StatusText(status), status)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json; charset=UTF-8")
        w.Header().Set("X-Content-Type-Options", "nosniff")
        w.WriteHeader(v.HTTPStatus())
        buf.WriteTo(w)</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package logger

import (
        "os"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

func CreateLogger(component string) *zap.Logger <span class="cov0" title="0">{
        stdout := zapcore.AddSync(os.Stdout)

        level := zap.NewAtomicLevelAt(zap.InfoLevel)

        productionCfg := zap.NewProductionEncoderConfig()
        productionCfg.TimeKey = "timestamp"
        productionCfg.EncodeTime = zapcore.ISO8601TimeEncoder

        developmentCfg := zap.NewDevelopmentEncoderConfig()
        developmentCfg.EncodeLevel = zapcore.CapitalColorLevelEncoder

        consoleEncoder := zapcore.NewConsoleEncoder(developmentCfg)

        core := zapcore.NewTee(
                zapcore.NewCore(consoleEncoder, stdout, level),
        )

        return zap.New(core, zap.Fields(zap.String("component", component)))
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package validation

import (
        "github.com/go-playground/validator/v10"
)

// allowedAlgorithms
var allowedAlgorithms = map[string]struct{}{
        "RSA": {},
        "ECC": {},
}

// registerRules
func registerRules(v *validator.Validate) <span class="cov0" title="0">{
        // algorithm = "RSA" | "ECC"
        _ = v.RegisterValidation("algorithm", func(fl validator.FieldLevel) bool </span><span class="cov0" title="0">{
                _, ok := allowedAlgorithms[fl.Field().String()]
                return ok
        }</span>)
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package validation

import (
        "strings"

        "github.com/go-playground/validator/v10"
)

var validate *validator.Validate

type ValidationError struct {
        Tag   string      `json:"tag"`
        Value interface{} `json:"value"`
}

func init() <span class="cov0" title="0">{
        validate = validator.New()
        registerRules(validate)
}</span>

// ValidateStruct used to validate struct
func ValidateStruct(s interface{}) error <span class="cov0" title="0">{
        return validate.Struct(s)
}</span>

func IsValidateError(err error) bool <span class="cov0" title="0">{
        if _, ok := err.(validator.ValidationErrors); ok </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func ValidateError(err error) map[string]ValidationError <span class="cov0" title="0">{
        errorMap := map[string]ValidationError{}
        for _, err := range err.(validator.ValidationErrors) </span><span class="cov0" title="0">{
                field := err.Namespace()
                ind := strings.Index(err.Namespace(), ".")
                if ind != -1 </span><span class="cov0" title="0">{
                        field = field[ind+1:]
                }</span>
                <span class="cov0" title="0">errorMap[field] = ValidationError{
                        Tag:   err.Tag(),
                        Value: err.Param(),
                }</span>
        }
        <span class="cov0" title="0">return errorMap</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package main

import "github.com/piotrklosek/signing-service-challenge-go/cmd"

func main() <span class="cov0" title="0">{
        cmd.Execute()
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package database

import (
        "context"

        "github.com/piotrklosek/signing-service-challenge-go/internal/domain"
)

// MockDeviceRepo implement DeviceRepository
type MockDeviceRepo struct {
        CreateFn  func(ctx context.Context, d *domain.SignatureDevice) error
        GetByIDFn func(ctx context.Context, id string) (*domain.SignatureDevice, error)
        ListFn    func(ctx context.Context) ([]*domain.SignatureDevice, error)
        UpdateFn  func(ctx context.Context, d *domain.SignatureDevice) error
}

// Create runs func or return nil
func (m *MockDeviceRepo) Create(ctx context.Context, d *domain.SignatureDevice) error <span class="cov0" title="0">{
        if m.CreateFn != nil </span><span class="cov0" title="0">{
                return m.CreateFn(ctx, d)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetByID runs func or return
func (m *MockDeviceRepo) GetByID(ctx context.Context, id string) (*domain.SignatureDevice, error) <span class="cov0" title="0">{
        if m.GetByIDFn != nil </span><span class="cov0" title="0">{
                return m.GetByIDFn(ctx, id)
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

// List runs func or return nil
func (m *MockDeviceRepo) List(ctx context.Context) ([]*domain.SignatureDevice, error) <span class="cov0" title="0">{
        if m.ListFn != nil </span><span class="cov0" title="0">{
                return m.ListFn(ctx)
        }</span>
        <span class="cov0" title="0">return []*domain.SignatureDevice{}, nil</span>
}

// Update runs func or return nil
func (m *MockDeviceRepo) Update(ctx context.Context, d *domain.SignatureDevice) error <span class="cov0" title="0">{
        if m.UpdateFn != nil </span><span class="cov0" title="0">{
                return m.UpdateFn(ctx, d)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package database

import (
        "context"

        "github.com/piotrklosek/signing-service-challenge-go/internal/domain"
)

// MockSignatureRepo implement SignatureRepository
type MockSignatureRepo struct {
        CreateFn       func(ctx context.Context, s *domain.SignatureRecord) error
        ListByDeviceFn func(ctx context.Context, deviceID string) ([]*domain.SignatureRecord, error)
}

// Create run func or return nil
func (m *MockSignatureRepo) Create(ctx context.Context, s *domain.SignatureRecord) error <span class="cov0" title="0">{
        if m.CreateFn != nil </span><span class="cov0" title="0">{
                return m.CreateFn(ctx, s)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ListByDevice run func or return empty list
func (m *MockSignatureRepo) ListByDevice(ctx context.Context, deviceID string) ([]*domain.SignatureRecord, error) <span class="cov0" title="0">{
        if m.ListByDeviceFn != nil </span><span class="cov0" title="0">{
                return m.ListByDeviceFn(ctx, deviceID)
        }</span>
        <span class="cov0" title="0">return []*domain.SignatureRecord{}, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package database

import (
        "context"

        "github.com/piotrklosek/signing-service-challenge-go/internal/domain"
)

// MockUserRepo impelemnting UserRepository
type MockUserRepo struct {
        CreateFn     func(ctx context.Context, u *domain.User) error
        GetByIDFn    func(ctx context.Context, id string) (*domain.User, error)
        GetByEmailFn func(ctx context.Context, email string) (*domain.User, error)
        ListFn       func(ctx context.Context) ([]*domain.User, error)
}

// Create run func or return nil
func (m *MockUserRepo) Create(ctx context.Context, u *domain.User) error <span class="cov0" title="0">{
        if m.CreateFn != nil </span><span class="cov0" title="0">{
                return m.CreateFn(ctx, u)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetByID run func or return nil
func (m *MockUserRepo) GetByID(ctx context.Context, id string) (*domain.User, error) <span class="cov0" title="0">{
        if m.GetByIDFn != nil </span><span class="cov0" title="0">{
                return m.GetByIDFn(ctx, id)
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

// GetByEmail run func or return nil
func (m *MockUserRepo) GetByEmail(ctx context.Context, email string) (*domain.User, error) <span class="cov0" title="0">{
        if m.GetByEmailFn != nil </span><span class="cov0" title="0">{
                return m.GetByEmailFn(ctx, email)
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

// List run func or return empty list
func (m *MockUserRepo) List(ctx context.Context) ([]*domain.User, error) <span class="cov0" title="0">{
        if m.ListFn != nil </span><span class="cov0" title="0">{
                return m.ListFn(ctx)
        }</span>
        <span class="cov0" title="0">return []*domain.User{}, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
